<!DOCTYPE html>
<html>
<head>
    <title>–ê—É–¥–∏–æ –∑–≤–æ–Ω–æ–∫</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        .call-container {
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        #endCall {
            background: #f44336;
        }
        #status {
            margin: 20px 0;
            color: #666;
            font-size: 18px;
        }
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9em;
            background: #f44336;
            color: white;
        }
        .connected #connection-status {
            background: #4CAF50;
        }
        .audio-indicator {
            width: 100px;
            height: 100px;
            margin: 30px auto;
            border-radius: 50%;
            background: #4285f4;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="connection-status">–û—Ç–∫–ª—é—á–µ–Ω–æ</div>

    <div class="call-container">
        <h2>–ê—É–¥–∏–æ –∑–≤–æ–Ω–æ–∫</h2>
        <p>ID –∑–≤–æ–Ω–∫–∞: {{ call_id }}</p>
        <div id="status">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∞—É–¥–∏–æ...</div>

        <div class="audio-indicator">
            <span>üîä</span>
        </div>

        <div class="controls">
            <button id="toggleAudio">–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</button>
            <button id="endCall">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
        </div>

        <div id="call-info">
            <p>–°–æ–µ–¥–∏–Ω–µ–Ω —Å: {{ call_id.split('_')[1] }}</p>
        </div>
    </div>

    <audio id="remoteAudio" autoplay></audio>
    <audio id="localAudio" muted style="display: none;"></audio>

    <script>
        const callId = "{{ call_id }}";
        const userId = "{{ user_id }}";
        const otherUserId = callId.split('_')[0] === userId ? callId.split('_')[1] : callId.split('_')[0];
        let peerConnection;
        let localStream;
        let isCaller = callId.startsWith(userId + '_');
        let isMuted = false;

        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const ws = new WebSocket(`${protocol}${window.location.host}/ws/${userId}`);

        function updateStatus(status) {
            const statusElement = document.getElementById("connection-status");
            statusElement.textContent = status;

            if (status === "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ") {
                document.body.classList.add('connected');
                statusElement.style.background = "#4CAF50";
            } else {
                document.body.classList.remove('connected');
                statusElement.style.background = "#f44336";
            }
        }

        ws.onopen = () => {
            updateStatus("–ü–æ–¥–∫–ª—é—á–µ–Ω–æ");
            startCall();
        };

        ws.onclose = () => {
            updateStatus("–û—Ç–∫–ª—é—á–µ–Ω–æ");
            endCall();
        };

        ws.onerror = (error) => {
            console.error("–û—à–∏–±–∫–∞ WebSocket:", error);
            updateStatus("–û—à–∏–±–∫–∞");
        };

        async function setupAudio() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        channelCount: 1
                    },
                    video: false
                });

                // Play local audio for feedback (muted)
                const localAudio = document.getElementById('localAudio');
                localAudio.srcObject = localStream;

                document.getElementById("status").textContent = "–ê—É–¥–∏–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ";
                console.log("–ê—É–¥–∏–æ –ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω");
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É:", error);
                document.getElementById("status").textContent = "–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –∑–∞–ø—Ä–µ—â–µ–Ω";
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.");
                endCall();
                throw error;
            }
        }

        function createPeerConnection() {
            const configuration = {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" },
                    { urls: "stun:stun2.l.google.com:19302" }
                ],
                iceTransportPolicy: "all",
                bundlePolicy: "max-bundle",
                rtcpMuxPolicy: "require"
            };

            peerConnection = new RTCPeerConnection(configuration);
            console.log("PeerConnection —Å–æ–∑–¥–∞–Ω");

            // Add audio tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
                console.log("–î–æ–±–∞–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫:", track.kind);
            });

            // ICE candidate handlers
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    console.log("–ù–æ–≤—ã–π ICE –∫–∞–Ω–¥–∏–¥–∞—Ç:", candidate);
                    ws.send(JSON.stringify({
                        type: "ice_candidate",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        candidate: candidate.toJSON()
                    }));
                }
            };

            // Handle remote stream
            peerConnection.ontrack = ({ streams: [remoteStream] }) => {
                console.log("–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π –ø–æ—Ç–æ–∫:", remoteStream);
                const remoteAudio = document.getElementById("remoteAudio");
                if (!remoteAudio.srcObject) {
                    remoteAudio.srcObject = remoteStream;
                    document.getElementById("status").textContent = "–ó–≤–æ–Ω–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω";
                    console.log("–£–¥–∞–ª–µ–Ω–Ω–æ–µ –∞—É–¥–∏–æ –ø–æ–¥–∫–ª—é—á–µ–Ω–æ");

                    // Handle audio play issues
                    const playPromise = remoteAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => console.log("–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ:", e));
                    }
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∏–∑–º–µ–Ω–∏–ª–æ—Å—å:", state);
                document.getElementById("status").textContent = `–°—Ç–∞—Ç—É—Å: ${state}`;

                if (state === "disconnected" || state === "failed") {
                    endCall();
                }
            };

            peerConnection.onicegatheringstatechange = () => {
                console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–±–æ—Ä–∞ ICE:", peerConnection.iceGatheringState);
            };

            peerConnection.onsignalingstatechange = () => {
                console.log("–°–∏–≥–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ:", peerConnection.signalingState);
            };
        }

        async function startCall() {
            try {
                await setupAudio();
                createPeerConnection();

                if (isCaller) {
                    try {
                        const offerOptions = {
                            offerToReceiveAudio: 1,
                            offerToReceiveVideo: 0
                        };

                        const offer = await peerConnection.createOffer(offerOptions);
                        await peerConnection.setLocalDescription(offer);
                        console.log("–°–æ–∑–¥–∞–Ω –æ—Ñ–µ—Ä:", offer);

                        ws.send(JSON.stringify({
                            type: "webrtc_offer",
                            from: userId,
                            to: otherUserId,
                            call_id: callId,
                            offer: peerConnection.localDescription.toJSON(),
                            is_audio_only: true
                        }));
                    } catch (error) {
                        console.error("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ñ–µ—Ä–∞:", error);
                        endCall();
                    }
                }
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –Ω–∞—á–∞–ª–∞ –∑–≤–æ–Ω–∫–∞:", error);
                endCall();
            }
        }

        // WebSocket message handler
        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            console.log("–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ WebSocket:", data);

            if (data.type === "webrtc_offer" && !isCaller) {
                try {
                    await setupAudio();
                    createPeerConnection();

                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.offer)
                    );
                    console.log("–£–¥–∞–ª–µ–Ω–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");

                    const answerOptions = {
                        voiceActivityDetection: false
                    };

                    const answer = await peerConnection.createAnswer(answerOptions);
                    await peerConnection.setLocalDescription(answer);
                    console.log("–°–æ–∑–¥–∞–Ω –æ—Ç–≤–µ—Ç:", answer);

                    ws.send(JSON.stringify({
                        type: "webrtc_answer",
                        from: userId,
                        to: data.from,
                        call_id: callId,
                        answer: peerConnection.localDescription.toJSON()
                    }));
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ñ–µ—Ä–∞:", error);
                    endCall();
                }
            }
            else if (data.type === "webrtc_answer" && isCaller) {
                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                    console.log("–û—Ç–≤–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω, –∑–≤–æ–Ω–æ–∫ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞:", error);
                    endCall();
                }
            }
            else if (data.type === "ice_candidate") {
                try {
                    if (data.candidate) {
                        await peerConnection.addIceCandidate(
                            new RTCIceCandidate(data.candidate)
                        );
                        console.log("–î–æ–±–∞–≤–ª–µ–Ω ICE –∫–∞–Ω–¥–∏–¥–∞—Ç:", data.candidate);
                    }
                } catch (error) {
                    console.error("–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–∞:", error);
                }
            }
        };

        // Call controls
        document.getElementById("endCall").addEventListener("click", endCall);
        document.getElementById("toggleAudio").addEventListener("click", toggleAudio);

        function toggleAudio() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                isMuted = !audioTracks[0].enabled;
                audioTracks.forEach(track => track.enabled = !isMuted);
                document.getElementById("toggleAudio").textContent =
                    isMuted ? "–í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫" : "–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫";

                const indicator = document.querySelector('.audio-indicator span');
                indicator.textContent = isMuted ? "üîá" : "üîä";
            }
        }

        function endCall() {
            console.log("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–≤–æ–Ω–∫–∞...");

            // Send call end notification
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: "call_end",
                    from: userId,
                    to: otherUserId,
                    call_id: callId
                }));
            }

            // Close connections
            if (peerConnection) {
                peerConnection.close();
                console.log("PeerConnection –∑–∞–∫—Ä—ã—Ç");
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                console.log("–õ–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
            }

            if (ws.readyState === WebSocket.OPEN) {
                ws.close();
                console.log("WebSocket –∑–∞–∫—Ä—ã—Ç");
            }

            // Return to chat
            window.location.href = `/chat/${userId}`;
        }

        // Handle page close
        window.addEventListener('beforeunload', endCall);
        window.addEventListener('pagehide', endCall);

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            console.log("–°—Ç—Ä–∞–Ω–∏—Ü–∞ –∑–≤–æ–Ω–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω–∞");
            updateStatus("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...");

            // Fix for iOS - trigger user gesture
            document.body.addEventListener('touchend', function initAudio() {
                // Remove this event listener after first touch
                document.body.removeEventListener('touchend', initAudio);

                // Try to play audio to unlock audio context
                const audio = new Audio();
                audio.volume = 0;
                audio.play().then(() => {
                    console.log("–ê—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω");
                }).catch(e => console.log("–û—à–∏–±–∫–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∞—É–¥–∏–æ:", e));
            }, false);
        });
    </script>
</body>
</html>
