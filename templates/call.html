\<!DOCTYPE html>
<html>
<head>
    <title>Video Call</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #video-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 45%;
            max-width: 500px;
            background: #000;
            border-radius: 8px;
        }
        #localVideo {
            transform: scaleX(-1);
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            margin: 0 5px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #endCall {
            background: #f44336;
        }
        #status {
            margin: 10px 0;
            color: #666;
        }
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            border-radius: 3px;
            font-size: 0.9em;
            background: #f44336;
            color: white;
        }
    </style>
</head>
<body>
    <div id="connection-status">Disconnected</div>
    <h2>Video Call</h2>
    <p>Call ID: {{ call_id }}</p>
    <div id="status">Connecting...</div>

    <div id="video-container">
        <video id="localVideo" autoplay muted playsinline></video>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <div class="controls">
        <button id="endCall">End Call</button>
        <button id="toggleAudio">Mute</button>
        <button id="toggleVideo">Hide Video</button>
    </div>

    <script>
        const callId = "{{ call_id }}";
        const userId = "{{ user_id }}";
        const parts = callId.split('_');
        const otherUserId = parts[0] === userId ? parts[1] : parts[0];
        let peerConnection;
        let localStream;
        let isCaller = parts[0] === userId;

        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const ws = new WebSocket(`${protocol}${window.location.host}/ws/${userId}`);

        function updateStatus(status) {
            document.getElementById("connection-status").textContent = status;
            document.getElementById("connection-status").style.background = 
                status === "Connected" ? "#4CAF50" : "#f44336";
        }

        ws.onopen = () => {
            updateStatus("Connected");
            startCall();
        };

        ws.onclose = () => {
            updateStatus("Disconnected");
            endCall();
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateStatus("Error");
        };

        // ICE servers configuration
        const iceServers = [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            { urls: "stun:stun2.l.google.com:19302" }
        ];

        async function setupMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                document.getElementById("localVideo").srcObject = localStream;
                document.getElementById("status").textContent = "Call connected";
            } catch (error) {
                console.error("Media device error:", error);
                document.getElementById("status").textContent = "Could not access camera/microphone";
                endCall();
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection({ iceServers });

            // Add local stream tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // ICE candidate handler
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    ws.send(JSON.stringify({
                        type: "ice_candidate",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        candidate: candidate.toJSON()
                    }));
                }
            };

            // Remote stream handler
            peerConnection.ontrack = ({ streams: [remoteStream] }) => {
                const remoteVideo = document.getElementById("remoteVideo");
                if (!remoteVideo.srcObject) {
                    remoteVideo.srcObject = remoteStream;
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                document.getElementById("status").textContent = `Status: ${state}`;
                if (state === "disconnected" || state === "failed") {
                    endCall();
                }
            };
        }

        async function startCall() {
            await setupMedia();
            createPeerConnection();

            if (isCaller) {
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    
                    ws.send(JSON.stringify({
                        type: "webrtc_offer",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        offer: peerConnection.localDescription.toJSON()
                    }));
                } catch (error) {
                    console.error("Offer creation error:", error);
                    endCall();
                }
            }
        }

        // WebSocket message handler
        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            
            if (data.type === "webrtc_offer" && !isCaller) {
                await setupMedia();
                createPeerConnection();
                
                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.offer)
                    );
                    
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    
                    ws.send(JSON.stringify({
                        type: "webrtc_answer",
                        from: userId,
                        to: data.from,
                        call_id: callId,
                        answer: peerConnection.localDescription.toJSON()
                    }));
                } catch (error) {
                    console.error("Answer error:", error);
                    endCall();
                }
            }
            else if (data.type === "webrtc_answer" && isCaller) {
                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                } catch (error) {
                    console.error("Answer handling error:", error);
                    endCall();
                }
            }
            else if (data.type === "ice_candidate") {
                try {
                    await peerConnection.addIceCandidate(
                        new RTCIceCandidate(data.candidate)
                    );
                } catch (error) {
                    console.error("ICE candidate error:", error);
                }
            }
        };

        // Call controls
        document.getElementById("endCall").addEventListener("click", endCall);
        document.getElementById("toggleAudio").addEventListener("click", () => {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                const isMuted = !audioTracks[0].enabled;
                audioTracks.forEach(track => track.enabled = isMuted);
                document.getElementById("toggleAudio").textContent = 
                    isMuted ? "Mute" : "Unmute";
            }
        });
        document.getElementById("toggleVideo").addEventListener("click", () => {
            if (localStream) {
                const videoTracks = localStream.getVideoTracks();
                const isHidden = !videoTracks[0].enabled;
                videoTracks.forEach(track => track.enabled = !isHidden);
                document.getElementById("toggleVideo").textContent = 
                    isHidden ? "Hide Video" : "Show Video";
            }
        });

        function endCall() {
            if (peerConnection) {
                peerConnection.close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            if (ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            window.location.href = `/chat/${userId}`;
        }

        // Initialize call when page loads
        window.addEventListener('beforeunload', endCall);
    </script>
</body>
</html>
