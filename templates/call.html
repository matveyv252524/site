<!DOCTYPE html>
<html>
<head>
    <title>–ê—É–¥–∏–æ –∑–≤–æ–Ω–æ–∫</title>
    <style>
        /* ... (–ø—Ä–µ–∂–Ω–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ... */
        .call-info {
            margin-bottom: 20px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div id="connection-status">–û—Ç–∫–ª—é—á–µ–Ω–æ</div>

    <div class="call-container">
        <h2>–ê—É–¥–∏–æ –∑–≤–æ–Ω–æ–∫</h2>
        <div class="call-info" id="callInfo"></div>
        <div id="status">–£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...</div>

        <div class="audio-indicator">
            <span id="audioIcon">üîä</span>
        </div>

        <div class="controls">
            <button id="toggleAudio">–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</button>
            <button id="endCall">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
        </div>
    </div>

    <audio id="remoteAudio" autoplay></audio>
    <audio id="localAudio" muted style="display: none;"></audio>

    <script>
        const callId = "{{ call_id }}";
        const userId = "{{ user_id }}";
        let peerConnection;
        let localStream;
        let isMuted = false;
        let isCaller = false;
        let otherUserId = null;
        let otherUsername = null;
        let callTimeout;

        // WebSocket connection
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const ws = new WebSocket(`${protocol}${window.location.host}/ws/${userId}`);

        function updateStatus(status) {
            const statusElement = document.getElementById("connection-status");
            statusElement.textContent = status;
            statusElement.style.background = status === "–ü–æ–¥–∫–ª—é—á–µ–Ω–æ" ? "#4CAF50" : "#f44336";
        }

        function updateCallInfo(text) {
            document.getElementById("callInfo").textContent = text;
        }

        function updateStatusText(text) {
            document.getElementById("status").textContent = text;
        }

        ws.onopen = () => {
            updateStatus("–ü–æ–¥–∫–ª—é—á–µ–Ω–æ");
            console.log("WebSocket connected");
            initializeCall();
        };

        ws.onclose = () => {
            updateStatus("–û—Ç–∫–ª—é—á–µ–Ω–æ");
            console.log("WebSocket disconnected");
            endCall();
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
            updateStatus("–û—à–∏–±–∫–∞");
            endCall();
        };

        ws.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            console.log("WebSocket message received:", data);

            if (data.type === "call_incoming") {
                otherUserId = data.from;
                otherUsername = `#${data.from}`;
                updateCallInfo(`–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ –æ—Ç ${otherUsername}`);
                isCaller = false;

                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è
                callTimeout = setTimeout(() => {
                    if (peerConnection && peerConnection.signalingState !== "closed") {
                        rejectCall();
                    }
                }, 30000);
            }
            else if (data.type === "call_accepted") {
                clearTimeout(callTimeout);
                otherUserId = data.from;
                otherUsername = `#${data.from}`;
                updateCallInfo(`–ó–≤–æ–Ω–æ–∫ —Å ${otherUsername}`);
                updateStatusText("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
            }
            else if (data.type === "call_rejected") {
                clearTimeout(callTimeout);
                updateStatusText("–ó–≤–æ–Ω–æ–∫ –æ—Ç–∫–ª–æ–Ω–µ–Ω");
                setTimeout(() => endCall(), 2000);
            }
            else if (data.type === "call_ended") {
                clearTimeout(callTimeout);
                updateStatusText("–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω");
                setTimeout(() => endCall(), 2000);
            }
            else if (data.type === "webrtc_offer" && !isCaller) {
                try {
                    await setupAudio();
                    createPeerConnection();

                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.offer)
                    );
                    console.log("Remote description set");

                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    console.log("Answer created");

                    ws.send(JSON.stringify({
                        type: "webrtc_answer",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        answer: peerConnection.localDescription
                    }));
                } catch (error) {
                    console.error("Error handling offer:", error);
                    endCall();
                }
            }
            else if (data.type === "webrtc_answer" && isCaller) {
                try {
                    await peerConnection.setRemoteDescription(
                        new RTCSessionDescription(data.answer)
                    );
                    console.log("Answer processed");
                    updateStatusText("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ");
                } catch (error) {
                    console.error("Error handling answer:", error);
                    endCall();
                }
            }
            else if (data.type === "ice_candidate") {
                try {
                    if (data.candidate) {
                        await peerConnection.addIceCandidate(
                            new RTCIceCandidate(data.candidate)
                        );
                        console.log("ICE candidate added");
                    }
                } catch (error) {
                    console.error("Error adding ICE candidate:", error);
                }
            }
        };

        async function initializeCall() {
            const callParts = callId.split('_');
            if (callParts.length === 3 && callParts[0] === userId) {
                // –ú—ã –∏–Ω–∏—Ü–∏–∞—Ç–æ—Ä –∑–≤–æ–Ω–∫–∞
                isCaller = true;
                otherUserId = callParts[1];
                otherUsername = `#${otherUserId}`;
                updateCallInfo(`–ó–≤–æ–Ω–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${otherUsername}`);

                try {
                    await setupAudio();
                    createPeerConnection();

                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);

                    ws.send(JSON.stringify({
                        type: "webrtc_offer",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        offer: peerConnection.localDescription,
                        is_audio_only: true
                    }));

                    // –¢–∞–π–º–∞—É—Ç –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
                    callTimeout = setTimeout(() => {
                        if (peerConnection && peerConnection.signalingState !== "closed") {
                            updateStatusText("–ù–µ—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è");
                            endCall();
                        }
                    }, 30000);
                } catch (error) {
                    console.error("Error starting call:", error);
                    endCall();
                }
            } else {
                // –ú—ã –ø–æ–ª—É—á–∞—Ç–µ–ª—å –∑–≤–æ–Ω–∫–∞, –∂–¥–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
                updateStatusText("–û–∂–∏–¥–∞–Ω–∏–µ –∑–≤–æ–Ω–∫–∞...");
            }
        }

        async function setupAudio() {
            try {
                updateStatusText("–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞...");
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    },
                    video: false
                });

                const localAudio = document.getElementById('localAudio');
                localAudio.srcObject = localStream;
                updateStatusText("–ú–∏–∫—Ä–æ—Ñ–æ–Ω –ø–æ–¥–∫–ª—é—á–µ–Ω");
            } catch (error) {
                console.error("Error accessing microphone:", error);
                updateStatusText("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É");
                alert("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏—è.");
                endCall();
                throw error;
            }
        }

        function createPeerConnection() {
            const configuration = {
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" },
                    { urls: "stun:stun2.l.google.com:19302" }
                ]
            };

            peerConnection = new RTCPeerConnection(configuration);

            // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ICE –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    ws.send(JSON.stringify({
                        type: "ice_candidate",
                        from: userId,
                        to: otherUserId,
                        call_id: callId,
                        candidate: candidate
                    }));
                }
            };

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
            peerConnection.ontrack = (event) => {
                const remoteAudio = document.getElementById("remoteAudio");
                if (!remoteAudio.srcObject) {
                    remoteAudio.srcObject = event.streams[0];
                    updateStatusText("–ó–≤–æ–Ω–æ–∫ –∞–∫—Ç–∏–≤–µ–Ω");

                    // –ü—ã—Ç–∞–µ–º—Å—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∞—É–¥–∏–æ (–º–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ)
                    remoteAudio.play().catch(e => console.log("Audio play error:", e));
                }
            };

            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                console.log("ICE connection state:", state);

                if (state === "disconnected" || state === "failed") {
                    updateStatusText("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ");
                    endCall();
                }
            };

            peerConnection.onicegatheringstatechange = () => {
                console.log("ICE gathering state:", peerConnection.iceGatheringState);
            };

            peerConnection.onsignalingstatechange = () => {
                console.log("Signaling state:", peerConnection.signalingState);
            };
        }

        function toggleAudio() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                isMuted = !audioTracks[0].enabled;
                audioTracks.forEach(track => track.enabled = !isMuted);
                document.getElementById("toggleAudio").textContent =
                    isMuted ? "–í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫" : "–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫";
                document.getElementById("audioIcon").textContent = isMuted ? "üîá" : "üîä";
            }
        }

        function rejectCall() {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: "call_reject",
                    from: userId,
                    to: otherUserId,
                    call_id: callId
                }));
            }
            endCall();
        }

        function endCall() {
            console.log("Ending call...");
            clearTimeout(callTimeout);

            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: "call_end",
                    from: userId,
                    to: otherUserId,
                    call_id: callId
                }));
                ws.close();
            }

            if (peerConnection) {
                peerConnection.close();
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }

            setTimeout(() => {
                window.location.href = `/chat/${userId}`;
            }, 1000);
        }

        // Event listeners
        document.getElementById("toggleAudio").addEventListener("click", toggleAudio);
        document.getElementById("endCall").addEventListener("click", endCall);

        // Handle page close
        window.addEventListener('beforeunload', endCall);
        window.addEventListener('pagehide', endCall);

        // iOS workaround - trigger user gesture
        document.addEventListener('click', function init() {
            // Try to play audio to unlock audio context
            const audio = new Audio();
            audio.volume = 0;
            audio.play().catch(e => console.log("Audio init error:", e));

            // Remove this event listener after first interaction
            document.removeEventListener('click', init);
        });
    </script>
</body>
</html>
